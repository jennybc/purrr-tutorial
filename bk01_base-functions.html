<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />




<title>Relationship to base and plyr functions</title>

<script src="site_libs/jquery-1.11.3/jquery.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/flatly.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<script src="site_libs/jqueryui-1.11.4/jquery-ui.min.js"></script>
<link href="site_libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="site_libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<link href="site_libs/highlightjs-1.1/default.css" rel="stylesheet" />
<script src="site_libs/highlightjs-1.1/highlight.js"></script>

<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>
<script type="text/javascript">
if (window.hljs && document.readyState && document.readyState === "complete") {
   window.setTimeout(function() {
      hljs.initHighlighting();
   }, 0);
}
</script>



<style type="text/css">
h1 {
  font-size: 34px;
}
h1.title {
  font-size: 38px;
}
h2 {
  font-size: 30px;
}
h3 {
  font-size: 24px;
}
h4 {
  font-size: 18px;
}
h5 {
  font-size: 16px;
}
h6 {
  font-size: 12px;
}
.table th:not([align]) {
  text-align: left;
}
</style>


</head>

<body>

<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
code {
  color: inherit;
  background-color: rgba(0, 0, 0, 0.04);
}
img {
  max-width:100%;
  height: auto;
}
.tabbed-pane {
  padding-top: 12px;
}
button.code-folding-btn:focus {
  outline: none;
}
</style>


<style type="text/css">
/* padding for bootstrap navbar */
body {
  padding-top: 60px;
  padding-bottom: 40px;
}
/* offset scroll position for anchor links (for fixed navbar)  */
.section h1 {
  padding-top: 65px;
  margin-top: -65px;
}

.section h2 {
  padding-top: 65px;
  margin-top: -65px;
}
.section h3 {
  padding-top: 65px;
  margin-top: -65px;
}
.section h4 {
  padding-top: 65px;
  margin-top: -65px;
}
.section h5 {
  padding-top: 65px;
  margin-top: -65px;
}
.section h6 {
  padding-top: 65px;
  margin-top: -65px;
}
</style>

<script>
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark it active
  menuAnchor.parent().addClass('active');

  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');
});
</script>


<div class="container-fluid main-container">

<!-- tabsets -->
<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});
</script>

<!-- code folding -->




<script>
$(document).ready(function ()  {

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2,h3",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_').toLowerCase();
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}


.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.9em;
  padding-left: 5px;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>

<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row-fluid">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">purrr tutorial</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="index.html">Lessons and examples</a>
</li>
<li>
  <a href="more-resources.html">More resources</a>
</li>
<li>
  <a href="slides.html">Slides</a>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li>
  <a href="about.html">About</a>
</li>
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div class="fluid-row" id="header">



<h1 class="title toc-ignore">Relationship to base and plyr functions</h1>

</div>


<div id="why-not-base" class="section level2">
<h2>Why not base?</h2>
<p>You need a way to iterate in R in a data-structure-informed way. What does that mean?</p>
<ul>
<li>Iterate over elements of a list</li>
<li>Iterate over sub data frames induced by one or more factors</li>
<li>Iterate over rows or columns of a 2-dimensional object</li>
<li>Iterate over tuples formed from the i-th element of several vectors of equal-length</li>
</ul>
<p>All of this is absolutely possible with base R, using <code>for()</code> loops or the “apply” functions, such as <code>apply()</code>, <code>[slvmt]apply()</code>, <code>split()</code>, and <code>by()</code>. I know, because I did so religiously for over 15 years.</p>
<p>What’s the problem? As an instructor, I encounter lots of useRs who sheepishly say they know they should be using the apply functions, but they don’t. Because they’ve never quite figured them out or been able to form the habit.</p>
<p>I have a theory about why. The apply functions are not particularly easy or convenient to use. The user interface is not as consistent as it could be, which slows down learning. The return objects frequently require further checking and massage to use downstream, which diminishes the payoff.</p>
</div>
<div id="why-purrr" class="section level2">
<h2>Why purrr?</h2>
<p>purrr addresses some of the friction identified in the base functions for “split-apply-combine”:</p>
<ul>
<li>The <code>map()</code> family of functions is highly internally consistent, making it easier to transfer expertise from one function to another.</li>
<li>Greater encouragement for type-safe simplification, i.e. conversion from list to atomic vector or data frame.</li>
<li>Concise syntax for defining anonymous functions.</li>
</ul>
<p>We load purrr now. Below we also use example lists from <a href="https://github.com/jennybc/repurrrsive">repurrrsive</a> which are <a href="index.html">introduced and explored elsewhere</a>.</p>
<pre class="r"><code>library(purrr)
## install_github(&quot;jennybc/repurrrsive&quot;)
library(repurrrsive)</code></pre>
</div>
<div id="why-not-plyr" class="section level2">
<h2>Why not plyr?</h2>
<p>If you have never heard of the <a href="https://CRAN.R-project.org/package=plyr">plyr package</a>, you can skip this section! Personally, I’m a bit sad that it’s time to move on from plyr. But it probably is.</p>
<p>Why? It’s no longer under active development. The innovation is happening elsewhere, in purrr and the other packages in the tidyverse. Also, even I must admit that plyr can be rather slow. I wouldn’t recommend writing new code that requires plyr.</p>
<p>In terms of understanding or translating plyr code, here’s the minimum you need to know: The key feature of the main 3 * 4 = 12 functions in plyr is their explicit, memorable form.</p>
<pre class="r"><code>XYply()</code></pre>
<p>where <code>X</code> and <code>Y</code> specify the type of input and output, respectively. <code>X</code> and <code>Y</code> take values from here:</p>
<ul>
<li><code>a</code> = “array”</li>
<li><code>d</code> = “data frame”</li>
<li><code>l</code> = “list”</li>
<li><code>_</code> = “nothing” (not eligible as <code>X</code> re: input, for obvious reasons)</li>
</ul>
<p>The most useful function proved to be <code>ddply()</code>: data frame in, data frame out. This is now handled by dplyr and tidyr. Most tasks suitable for <code>a*ply()</code> and, especially <code>l*ply()</code> are now handled by purrr’s <code>map()</code> family. The functions called for their side effects, as opposed to return value, are those named <code>*_ply()</code>; this is handled by purrr’s <code>walk()</code> functions. Marching through a data frame row by row is now a job for purrr’s <code>pmap()</code>.</p>
</div>
<div id="lapply-vs.-purrrmap" class="section level2">
<h2><code>lapply()</code> vs. <code>purrr::map()</code></h2>
<p>These are the core mapping functions of base and purrr, respectively. They are “list in, list out”. The main (only?) difference is access to purrr’s shortcuts for anonymous functions.</p>
<div class="row">
<div class="col-md-6">
<pre class="r"><code>lapply(got_chars[1:3],
       function(x) x[[&quot;name&quot;]])
#&gt; [[1]]
#&gt; [1] &quot;Arya Stark&quot;
#&gt; 
#&gt; [[2]]
#&gt; [1] &quot;Brandon Stark&quot;
#&gt; 
#&gt; [[3]]
#&gt; [1] &quot;Catelyn Stark&quot;</code></pre>
</div>
<div class="col-md-6">
<pre class="r"><code>map(got_chars[1:3], &quot;name&quot;)
#&gt; [[1]]
#&gt; [1] &quot;Arya Stark&quot;
#&gt; 
#&gt; [[2]]
#&gt; [1] &quot;Brandon Stark&quot;
#&gt; 
#&gt; [[3]]
#&gt; [1] &quot;Catelyn Stark&quot;</code></pre>
</div>
</div>
<p>This is also <code>plyr::llply()</code>, although it offers some other arguments, such as <code>.progress</code> and <code>.parallel</code>.</p>
<pre class="r"><code>plyr::llply(got_chars[1:3], function(x) x[[&quot;name&quot;]])</code></pre>
</div>
<div id="sapply-vs.-__" class="section level2">
<h2><code>sapply()</code> vs. ¯\_(ツ)_/¯</h2>
<p><code>sapply()</code> is a base function that attempts to apply a reasonable simplification to the output of <code>lapply()</code>. It’s fine for interactive use, but due to the unpredictability of it return value, it’s unwise to use it in programming. There is no equivalent in purrr or plyr.</p>
<p>Problem demonstration: The characters in Game of Thrones can have aliases. Some have several, some have one, some have none. Depending on which characters I work with, the same <code>sapply()</code> call can return an object of entirely different class, i.e. a list or a character vector. This can be a source of mysterious bugs in code meant to run non-interactively.</p>
<pre class="r"><code>aliases1 &lt;- sapply(got_chars[2:4], function(x) x[[&quot;aliases&quot;]])
str(aliases1)
#&gt; List of 3
#&gt;  $ : chr [1:3] &quot;Bran&quot; &quot;Bran the Broken&quot; &quot;The Winged Wolf&quot;
#&gt;  $ : chr [1:5] &quot;Catelyn Tully&quot; &quot;Lady Stoneheart&quot; &quot;The Silent Sistet&quot; &quot;Mother Mercilesr&quot; ...
#&gt;  $ : chr [1:3] &quot;Ned&quot; &quot;The Ned&quot; &quot;The Quiet Wolf&quot;
aliases2 &lt;- sapply(got_chars[c(14, 22, 25)], function(x) x[[&quot;aliases&quot;]])
str(aliases2)
#&gt;  chr [1:3] &quot;Merrett Muttonhead&quot; &quot;The Iron Captain&quot; ...</code></pre>
<p>With purrr, you would use <code>map()</code> to get a list back or <code>map_chr()</code> to get atomic character vector. If you use <code>map_chr()</code> when you should not, you’ll get an error and can adjust your approach accordingly.</p>
<pre class="r"><code>map_chr(got_chars[2:4], &quot;aliases&quot;)
#&gt; Error: Result 1 is not a length 1 atomic vector</code></pre>
</div>
<div id="vapply-vs.-map_" class="section level2">
<h2><code>vapply()</code> vs. <code>map_*()</code></h2>
<p>Base <code>vapply()</code> requires you to specify a template for the return value and is described as a safer alternative to <code>sapply()</code>. The closest purrr functions are the type-specific mapping functions: <code>map_lgl()</code>, <code>map_int()</code>, <code>map_dbl()</code>, and <code>map_chr()</code>. Here’s comparable use of <code>vapply()</code> and <code>map_chr()</code> to get some of the Game of Thrones characters’ names.</p>
<div class="row">
<div class="col-md-6">
<pre class="r"><code>vapply(got_chars[1:3],
       function(x) x[[&quot;name&quot;]], character(1))
#&gt; [1] &quot;Arya Stark&quot;    &quot;Brandon Stark&quot; &quot;Catelyn Stark&quot;</code></pre>
</div>
<div class="col-md-6">
<pre class="r"><code>map_chr(got_chars[1:3], &quot;name&quot;)
#&gt; [1] &quot;Arya Stark&quot;    &quot;Brandon Stark&quot; &quot;Catelyn Stark&quot;</code></pre>
</div>
</div>
<p>What’s not to love with <code>vapply()</code> then? It suffers from the <code>drop = FALSE</code> problem we can have when requesting columns of 2-dimensional objects. Except <code>vapply()</code> has no <code>drop</code> argument to control this behavior! It’s another example of the base functions being more difficult to program around.</p>
<p>I adapt this example from my real life, where I have <code>vapply()</code> inside a function and <code>n</code> is an argument to that function, i.e. it varies. Here I just define <code>n</code> prior to the <code>vapply()</code> call. Note how <code>vapply()</code> returns a 2 dimensional object in the first case and atomic vector in the second. As it says in the docs: “Simplification is always done in <code>vapply</code>.” Believe it.</p>
<pre class="r"><code>f &lt;- function(x, n) rep(x, n)
n &lt;- 3
vapply(c(&quot;a&quot;, &quot;b&quot;), f, character(n), n = n)
#&gt;      a   b  
#&gt; [1,] &quot;a&quot; &quot;b&quot;
#&gt; [2,] &quot;a&quot; &quot;b&quot;
#&gt; [3,] &quot;a&quot; &quot;b&quot;
n &lt;- 1
vapply(c(&quot;a&quot;, &quot;b&quot;), f, character(n), n = n)
#&gt;   a   b 
#&gt; &quot;a&quot; &quot;b&quot;</code></pre>
</div>
<div id="mapply-vs.-map2-pmap" class="section level2">
<h2><code>mapply()</code> vs. <code>map2()</code>, <code>pmap()</code></h2>
<p><em>for when you want to iterate over the i-th elements of multiple vectors/lists</em></p>
</div>
<div id="tapply-aggregate" class="section level2">
<h2><code>tapply()</code>, <code>aggregate()</code></h2>
<p><em>for when you want to chop a vector or data frame into pieces based on one or more factors and compute on the pieces … tidyverse way would be <code>group_by() + summarize()</code> or <code>map()</code> inside <code>mutate()</code> with a nested data frame or <code>map()</code> over a list of split data frames … this gets a bit off topic, i.e. more into dplyr/tidyr territory??? … issue w/ <code>tapply()</code> and data.frame method of <code>aggregate()</code> is there’s no concept of common data frame for the splitter and splittee, return values quite variable</em></p>
<pre class="r"><code>library(gapminder)
mini_gap &lt;- gapminder %&gt;%
  dplyr::filter(country %in% c(&quot;Canada&quot;, &quot;Germany&quot;), year &gt; 2000) %&gt;% 
  droplevels()

## in this specific case, output is quite nice
aggregate(lifeExp ~ country, mini_gap, mean) 
#&gt;   country lifeExp
#&gt; 1  Canada 80.2115
#&gt; 2 Germany 79.0380

## frustrating that mini_gap can&#39;t be specified as the data frame in which to
## find everything ... Group.1?
aggregate(mini_gap[c(&quot;lifeExp&quot;, &quot;gdpPercap&quot;)], list(mini_gap$country), mean)
#&gt;   Group.1 lifeExp gdpPercap
#&gt; 1  Canada 80.2115  34824.10
#&gt; 2 Germany 79.0380  31103.09

## named vector comes back
tapply(mini_gap$lifeExp, mini_gap$country, mean)
#&gt;  Canada Germany 
#&gt; 80.2115 79.0380

## or a list ... but what you really want is a data frame
tapply(mini_gap$lifeExp, mini_gap$country, mean, simplify = FALSE)
#&gt; $Canada
#&gt; [1] 80.2115
#&gt; 
#&gt; $Germany
#&gt; [1] 79.038</code></pre>
</div>

<p><a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/"><img alt="Creative Commons License" style="border-width:0" src="by-nc.png" height="400" width="65"/></a></p>


</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.header').parent('thead').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
